================================================================================
NODE.JS FUNDAMENTALS - A COMPLETE BEGINNER'S GUIDE
================================================================================

This guide explains Node.js from the ground up, assuming no prior knowledge.
We'll start with the big picture and progressively dive deeper into specifics.

================================================================================
PART 1: THE BIG PICTURE - WHAT IS NODE.JS?
================================================================================

THE SIMPLEST EXPLANATION
------------------------
Node.js lets you run JavaScript outside of a web browser.

Before Node.js (2009), JavaScript could ONLY run inside browsers like Chrome
or Firefox. If you wanted to build a server, you needed other languages like
Python, Java, or PHP.

Node.js changed that. Now you can use JavaScript for:
- Web servers (what we do in this app)
- Command-line tools
- Desktop applications
- IoT devices
- And much more

WHY THIS MATTERS
----------------
Imagine JavaScript as a language you speak. Before Node.js:
- In the browser: You could speak JavaScript
- On a server: You had to speak a different language (Python, Java, etc.)

After Node.js:
- In the browser: JavaScript
- On the server: JavaScript (same language!)

This means:
1. One language for your entire application
2. Share code between frontend and backend
3. Easier for developers to work on both sides

THE ENGINE UNDER THE HOOD
-------------------------
Node.js is built on Chrome's V8 JavaScript engine - the same thing that makes
JavaScript fast in Chrome. Google spent millions making V8 incredibly fast,
and Node.js benefits from all that work.

================================================================================
PART 2: HOW NODE.JS WORKS
================================================================================

THE EVENT LOOP - Node's Secret Sauce
------------------------------------
Node.js is "single-threaded" but can handle thousands of requests. How?

Think of a restaurant with ONE waiter (single thread):

TRADITIONAL APPROACH (like Java/PHP):
  Customer 1 orders → Waiter waits in kitchen until food ready → Serves food
  Customer 2 orders → Waiter waits in kitchen until food ready → Serves food
  (Each customer waits for the one before them!)

NODE.JS APPROACH:
  Customer 1 orders → Waiter gives order to kitchen, moves on
  Customer 2 orders → Waiter gives order to kitchen, moves on
  Customer 3 orders → Waiter gives order to kitchen, moves on
  Kitchen says "Order 1 ready!" → Waiter serves Customer 1
  Kitchen says "Order 3 ready!" → Waiter serves Customer 3
  Kitchen says "Order 2 ready!" → Waiter serves Customer 2

The waiter (Node.js) never waits idly. When something slow happens (cooking,
database query, file read), Node moves on to other tasks and comes back when
the slow thing is done.

This is called "non-blocking I/O" and the "Event Loop":
- Non-blocking: Don't wait for slow operations
- I/O: Input/Output (reading files, network requests, database queries)
- Event Loop: The mechanism that checks "is anything ready?" and handles it

VISUALIZING THE EVENT LOOP
--------------------------
```
     ┌───────────────────────────┐
  ┌──│         Call Stack        │  ← Currently executing code
  │  └───────────────────────────┘
  │               ↓
  │  ┌───────────────────────────┐
  │  │        Event Loop         │  ← Checks for completed tasks
  │  └───────────────────────────┘
  │               ↓
  │  ┌───────────────────────────┐
  │  │     Callback Queue        │  ← Tasks waiting to run
  │  └───────────────────────────┘
  │               ↑
  │  ┌───────────────────────────┐
  └──│  Background Operations    │  ← File I/O, Network, Timers
     └───────────────────────────┘
```

1. Your code runs in the Call Stack
2. Slow operations go to Background
3. When complete, callbacks go to Queue
4. Event Loop moves callbacks to Stack when Stack is empty
5. Repeat forever

================================================================================
PART 3: JAVASCRIPT ON THE SERVER vs BROWSER
================================================================================

WHAT'S THE SAME
---------------
- Variables, functions, loops, conditions
- Objects, arrays, strings
- Promises, async/await
- Classes and modules
- All the core JavaScript syntax

WHAT'S DIFFERENT
----------------

IN BROWSER (what you might know):
```javascript
// DOM manipulation - browser only!
document.getElementById("button").click();

// Window object - browser only!
window.alert("Hello!");

// Browser APIs
localStorage.setItem("key", "value");
fetch("https://api.example.com/data");
```

IN NODE.JS (what we use on server):
```javascript
// File system - Node only!
const fs = require("fs");
fs.readFileSync("file.txt");

// Path manipulation - Node only!
const path = require("path");
path.join("/users", "john", "file.txt");

// Create HTTP servers - Node only!
const http = require("http");
http.createServer((req, res) => { ... });

// Environment variables
process.env.DATABASE_URL;

// Current directory
__dirname;  // "/home/user/myapp"
```

NODE HAS NO:
- window object
- document object
- DOM (no HTML elements)
- alert(), prompt()
- localStorage

NODE HAS EXTRA:
- fs (file system)
- path (file paths)
- http (create servers)
- process (system info)
- Buffer (binary data)
- And hundreds of built-in modules

================================================================================
PART 4: MODULES - ORGANIZING CODE
================================================================================

WHAT IS A MODULE?
-----------------
A module is a file that contains code you want to reuse. Instead of putting
everything in one giant file, you split code into logical pieces.

Think of modules like LEGO bricks - small, reusable pieces you combine.

TYPES OF MODULES IN NODE.JS
---------------------------

1. BUILT-IN MODULES (come with Node.js)
```javascript
const fs = require("fs");       // File system
const path = require("path");   // File paths
const http = require("http");   // HTTP server
const crypto = require("crypto"); // Encryption
```

2. YOUR OWN MODULES (files you create)
```javascript
// math.js (your file)
function add(a, b) {
  return a + b;
}
module.exports = { add };

// app.js (another file)
const math = require("./math");  // Note the ./
console.log(math.add(2, 3));     // 5
```

3. NPM PACKAGES (third-party modules)
```javascript
const express = require("express");  // Web framework
const lodash = require("lodash");    // Utility functions
```

TWO MODULE SYSTEMS
------------------
Node.js has two ways to import/export modules:

COMMONJS (older, still widely used):
```javascript
// Exporting
module.exports = { functionName };
// or
exports.functionName = function() { ... };

// Importing
const module = require("./module");
const { functionName } = require("./module");
```

ES MODULES (newer, what we use):
```javascript
// Exporting
export function functionName() { ... }
export default class MyClass { ... }

// Importing
import { functionName } from "./module";
import MyClass from "./module";
```

Our app uses ES Modules (the `import`/`export` syntax) because it's the
modern standard and works well with TypeScript.

================================================================================
PART 5: NPM - THE PACKAGE MANAGER
================================================================================

WHAT IS NPM?
------------
NPM = Node Package Manager

It's like an app store for code. Instead of writing everything yourself,
you can download packages that other developers have created.

There are over 2 MILLION packages available!

THE package.json FILE
---------------------
Every Node.js project has a package.json file. It's like a recipe card that
lists everything your project needs.

```json
{
  "name": "my-app",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2",
    "drizzle-orm": "^0.29.0"
  },
  "devDependencies": {
    "typescript": "^5.0.0"
  },
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  }
}
```

KEY SECTIONS:
- name/version: Identity of your project
- dependencies: Packages your app needs to RUN
- devDependencies: Packages needed only for DEVELOPMENT
- scripts: Shortcuts for common commands

COMMON NPM COMMANDS
-------------------
```bash
npm install              # Install all dependencies from package.json
npm install express      # Install a specific package
npm install -D nodemon   # Install as dev dependency (-D)
npm uninstall express    # Remove a package
npm run dev              # Run the "dev" script from package.json
npm start                # Special: runs "start" script
```

THE node_modules FOLDER
-----------------------
When you run `npm install`, packages are downloaded to node_modules/.

This folder can be HUGE (sometimes 100MB+) because each package might have
its own dependencies, which have their own dependencies, and so on.

IMPORTANT: Never edit files in node_modules. Never commit it to git.
The package.json tells npm exactly what to download.

================================================================================
PART 6: ASYNCHRONOUS JAVASCRIPT IN NODE
================================================================================

THE PROBLEM
-----------
Some operations are SLOW:
- Reading a file: ~10 milliseconds
- Database query: ~50 milliseconds
- API request: ~200 milliseconds

If Node.js waited for each one, your server would be very slow.

THE SOLUTION: DON'T WAIT
------------------------
Node.js starts the slow operation and moves on. When it's done, a "callback"
function runs with the result.

THREE WAYS TO HANDLE ASYNC CODE
-------------------------------

1. CALLBACKS (oldest way)
```javascript
// The "callback" runs when the file is read
fs.readFile("file.txt", (error, data) => {
  if (error) {
    console.log("Error:", error);
    return;
  }
  console.log("File contents:", data);
});
console.log("This runs BEFORE the file is read!");
```

Output:
```
This runs BEFORE the file is read!
File contents: Hello World
```

The problem: "Callback Hell" when nesting many callbacks:
```javascript
fs.readFile("file1.txt", (err, data1) => {
  fs.readFile("file2.txt", (err, data2) => {
    fs.readFile("file3.txt", (err, data3) => {
      // Deeply nested, hard to read!
    });
  });
});
```

2. PROMISES (better)
```javascript
const fsPromises = require("fs").promises;

fsPromises.readFile("file.txt")
  .then(data => {
    console.log("File contents:", data);
    return fsPromises.readFile("file2.txt");
  })
  .then(data2 => {
    console.log("File 2:", data2);
  })
  .catch(error => {
    console.log("Error:", error);
  });
```

Better, but still uses .then() chaining.

3. ASYNC/AWAIT (best - what we use)
```javascript
async function readFiles() {
  try {
    const data1 = await fsPromises.readFile("file1.txt");
    const data2 = await fsPromises.readFile("file2.txt");
    const data3 = await fsPromises.readFile("file3.txt");
    console.log(data1, data2, data3);
  } catch (error) {
    console.log("Error:", error);
  }
}
```

Looks like normal synchronous code! Much easier to read.

UNDERSTANDING async/await
-------------------------
- `async` before a function means it returns a Promise
- `await` pauses execution until the Promise resolves
- `await` can ONLY be used inside `async` functions
- Use `try/catch` for error handling

```javascript
// These are equivalent:

// Promise version
function fetchUser() {
  return fetch("/api/user")
    .then(response => response.json());
}

// async/await version
async function fetchUser() {
  const response = await fetch("/api/user");
  return response.json();
}
```

================================================================================
PART 7: CORE NODE.JS MODULES
================================================================================

FS (FILE SYSTEM)
----------------
Read, write, delete, and manipulate files.

```javascript
import * as fs from "fs";
import * as fsPromises from "fs/promises";

// Check if file exists
fs.existsSync("file.txt");  // true or false

// Read file (sync - blocks execution)
const content = fs.readFileSync("file.txt", "utf-8");

// Read file (async - doesn't block)
const content = await fsPromises.readFile("file.txt", "utf-8");

// Write file
fs.writeFileSync("file.txt", "Hello World");
await fsPromises.writeFile("file.txt", "Hello World");

// Create directory
fs.mkdirSync("new-folder", { recursive: true });

// Delete file
fs.unlinkSync("file.txt");

// List files in directory
const files = fs.readdirSync("./my-folder");
```

PATH
----
Work with file paths safely across different operating systems.

```javascript
import * as path from "path";

// Join paths (handles slashes correctly)
path.join("/users", "john", "file.txt");
// Result: "/users/john/file.txt" (Unix)
// Result: "\\users\\john\\file.txt" (Windows)

// Get file extension
path.extname("photo.jpg");  // ".jpg"

// Get filename without extension
path.basename("photo.jpg", ".jpg");  // "photo"

// Get directory name
path.dirname("/users/john/file.txt");  // "/users/john"

// Resolve to absolute path
path.resolve("./file.txt");  // "/full/path/to/file.txt"
```

HTTP
----
Create web servers (though we use Express which builds on this).

```javascript
import * as http from "http";

const server = http.createServer((request, response) => {
  response.writeHead(200, { "Content-Type": "text/plain" });
  response.end("Hello World");
});

server.listen(3000, () => {
  console.log("Server running at http://localhost:3000");
});
```

PROCESS
-------
Information about and control over the current Node.js process.

```javascript
// Environment variables
process.env.DATABASE_URL;
process.env.NODE_ENV;  // "development" or "production"

// Command line arguments
process.argv;  // ["node", "app.js", "arg1", "arg2"]

// Current working directory
process.cwd();  // "/home/user/my-app"

// Exit the process
process.exit(0);  // 0 = success, 1 = error

// Platform
process.platform;  // "linux", "darwin" (Mac), "win32"
```

CHILD_PROCESS
-------------
Run other programs from Node.js. We use this for yt-dlp!

```javascript
import { spawn, exec } from "child_process";

// spawn - for long-running processes with streaming output
const process = spawn("yt-dlp", ["--extract-audio", "video-url"]);

process.stdout.on("data", (data) => {
  console.log("Output:", data.toString());
});

process.stderr.on("data", (data) => {
  console.log("Error:", data.toString());
});

process.on("close", (code) => {
  console.log("Process exited with code:", code);
});

// exec - for quick commands with buffered output
exec("ls -la", (error, stdout, stderr) => {
  console.log(stdout);
});
```

================================================================================
PART 8: EXPRESS.JS - THE WEB FRAMEWORK
================================================================================

WHY EXPRESS?
------------
The built-in `http` module is low-level. You'd have to:
- Parse URLs manually
- Parse request bodies manually
- Handle routing manually
- Handle errors manually

Express does all this for you!

BASIC EXPRESS APP
-----------------
```javascript
import express from "express";

const app = express();

// Middleware - runs on EVERY request
app.use(express.json());  // Parse JSON bodies

// Route handlers
app.get("/", (req, res) => {
  res.send("Hello World");
});

app.get("/users/:id", (req, res) => {
  const userId = req.params.id;  // Get :id from URL
  res.json({ id: userId, name: "John" });
});

app.post("/users", (req, res) => {
  const userData = req.body;  // Get data from request body
  res.status(201).json({ created: true, user: userData });
});

// Start server
app.listen(3000, () => {
  console.log("Server running on port 3000");
});
```

THE REQUEST OBJECT (req)
------------------------
Contains information about the incoming request.

```javascript
app.get("/search", (req, res) => {
  req.method;       // "GET"
  req.path;         // "/search"
  req.query;        // { q: "hello", page: "1" } from /search?q=hello&page=1
  req.params;       // { id: "123" } from /users/:id
  req.body;         // POST data (after using express.json())
  req.headers;      // { "content-type": "application/json", ... }
  req.cookies;      // { sessionId: "abc123" }
});
```

THE RESPONSE OBJECT (res)
-------------------------
Used to send data back to the client.

```javascript
app.get("/example", (req, res) => {
  // Send plain text
  res.send("Hello");
  
  // Send JSON
  res.json({ message: "Hello" });
  
  // Set status code
  res.status(404).json({ error: "Not found" });
  
  // Send file
  res.sendFile("/path/to/file.pdf");
  
  // Redirect
  res.redirect("/other-page");
  
  // Set headers
  res.setHeader("Content-Type", "text/html");
  
  // Set cookie
  res.cookie("name", "value");
});
```

MIDDLEWARE
----------
Middleware are functions that run BEFORE your route handlers. They can:
- Modify req/res objects
- End the request early
- Call next() to continue to next middleware

```javascript
// Built-in middleware
app.use(express.json());           // Parse JSON bodies
app.use(express.static("public")); // Serve static files

// Custom middleware
app.use((req, res, next) => {
  console.log(`${req.method} ${req.path}`);  // Log every request
  next();  // Continue to next middleware/route
});

// Middleware for specific routes
app.use("/api", authMiddleware);  // Only for /api/* routes

// Error handling middleware (must have 4 parameters)
app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).json({ error: "Something broke!" });
});
```

ROUTING
-------
```javascript
// Basic routes
app.get("/users", getAllUsers);
app.get("/users/:id", getUser);
app.post("/users", createUser);
app.patch("/users/:id", updateUser);
app.delete("/users/:id", deleteUser);

// Route parameters
app.get("/users/:userId/posts/:postId", (req, res) => {
  const { userId, postId } = req.params;
  // userId and postId are strings!
});

// Router for grouping routes
import { Router } from "express";
const router = Router();

router.get("/", getAllUsers);
router.post("/", createUser);

app.use("/api/users", router);
// Now: GET /api/users, POST /api/users, etc.
```

================================================================================
PART 9: HOW THIS APP USES NODE.JS
================================================================================

Let's look at specific examples from our codebase:

SERVER STARTUP (server/index.ts)
--------------------------------
```typescript
import express from "express";
import { registerRoutes } from "./routes";

const app = express();
app.use(express.json());  // Parse JSON request bodies

// Register all our API routes
const server = await registerRoutes(httpServer, app);

// Start listening
server.listen(5000, "0.0.0.0", () => {
  console.log("Server running on port 5000");
});
```

API ROUTES (server/routes.ts)
-----------------------------
```typescript
// YouTube search endpoint
app.get("/api/search", async (req, res) => {
  const query = req.query.q as string;  // Get ?q= from URL
  
  if (!query) {
    return res.status(400).json({ message: "Query required" });
  }
  
  const results = await searchYouTube(query);  // Call YouTube API
  res.json({ results });  // Send back as JSON
});

// Download endpoint using child_process
app.post("/api/download", async (req, res) => {
  const { videoId, title } = req.body;
  
  // Set up Server-Sent Events for progress updates
  res.setHeader("Content-Type", "text/event-stream");
  
  // Run yt-dlp as external process
  const ytdlp = spawn("yt-dlp", [
    "--extract-audio",
    "--audio-format", "mp3",
    `https://www.youtube.com/watch?v=${videoId}`
  ]);
  
  // Send progress to client
  ytdlp.stdout.on("data", (data) => {
    const progress = parseProgress(data.toString());
    res.write(`data: ${JSON.stringify({ progress })}\n\n`);
  });
  
  // Send completion
  ytdlp.on("close", () => {
    res.write(`data: ${JSON.stringify({ status: "complete" })}\n\n`);
    res.end();
  });
});
```

FILE OPERATIONS (downloading)
-----------------------------
```typescript
import * as fs from "fs";
import * as path from "path";

// Create downloads directory if it doesn't exist
const DOWNLOAD_DIR = path.join(process.cwd(), "downloads");
if (!fs.existsSync(DOWNLOAD_DIR)) {
  fs.mkdirSync(DOWNLOAD_DIR, { recursive: true });
}

// Save downloaded file
const filePath = path.join(DOWNLOAD_DIR, `${sanitizedTitle}.mp3`);
// yt-dlp writes directly to this path
```

DATABASE CONNECTION (server/db.ts)
----------------------------------
```typescript
import { drizzle } from "drizzle-orm/neon-http";

// Get database URL from environment
const databaseUrl = process.env.DATABASE_URL;

// Create database connection
export const db = drizzle(databaseUrl);
```

================================================================================
PART 10: COMMON PATTERNS AND BEST PRACTICES
================================================================================

ERROR HANDLING
--------------
Always wrap async code in try/catch:

```typescript
app.get("/api/data", async (req, res) => {
  try {
    const data = await fetchData();
    res.json(data);
  } catch (error) {
    console.error("Error:", error);
    res.status(500).json({ message: "Something went wrong" });
  }
});
```

ENVIRONMENT VARIABLES
---------------------
Never hardcode sensitive data. Use environment variables:

```typescript
// BAD
const apiKey = "sk-1234567890";

// GOOD
const apiKey = process.env.API_KEY;
if (!apiKey) {
  throw new Error("API_KEY environment variable is required");
}
```

VALIDATION
----------
Always validate user input:

```typescript
app.post("/api/songs", async (req, res) => {
  const { title, artist } = req.body;
  
  // Validate required fields
  if (!title || typeof title !== "string") {
    return res.status(400).json({ message: "Title is required" });
  }
  
  // Use Zod for complex validation (what we use)
  const result = songSchema.safeParse(req.body);
  if (!result.success) {
    return res.status(400).json({ errors: result.error.issues });
  }
  
  // Now safe to use
  const song = await createSong(result.data);
  res.json(song);
});
```

STRUCTURED RESPONSES
--------------------
Be consistent with your API responses:

```typescript
// Success response
res.json({
  success: true,
  data: { ... }
});

// Error response
res.status(400).json({
  success: false,
  message: "What went wrong"
});
```

================================================================================
PART 11: DEBUGGING NODE.JS
================================================================================

CONSOLE LOGGING
---------------
```typescript
console.log("Simple message");
console.log("Object:", { name: "John", age: 30 });
console.log("Multiple:", var1, var2, var3);

console.error("Error message");  // Prints to stderr
console.warn("Warning message");
console.table([{ a: 1 }, { a: 2 }]);  // Pretty table

// Time operations
console.time("operation");
await slowOperation();
console.timeEnd("operation");  // "operation: 245.2ms"
```

DEBUGGING WITH NODE INSPECTOR
-----------------------------
```bash
# Run with inspector
node --inspect server.js

# Then open Chrome and go to chrome://inspect
```

COMMON ERRORS AND FIXES
-----------------------

1. "Cannot find module 'xyz'"
   - Run `npm install xyz`
   - Check spelling of import path
   - Check if using ./ for local files

2. "Cannot use import statement outside a module"
   - Add "type": "module" to package.json
   - Or use require() instead of import

3. "EADDRINUSE: address already in use"
   - Another process is using that port
   - Kill it: `lsof -i :3000` then `kill <PID>`
   - Or use a different port

4. "ENOENT: no such file or directory"
   - File path is wrong
   - File doesn't exist
   - Use path.join() for cross-platform paths

================================================================================
PART 12: GLOSSARY OF NODE.JS TERMS
================================================================================

async/await - Syntax for handling asynchronous code that looks synchronous.

Buffer - Node.js type for handling binary data (files, network data).

Callback - A function passed to another function, called when work is done.

CommonJS - Node's original module system using require() and module.exports.

ES Modules - Modern module system using import and export keywords.

Event Loop - The mechanism that handles asynchronous operations in Node.js.

Express - The most popular web framework for Node.js.

Middleware - Functions that process requests before they reach route handlers.

Module - A reusable piece of code, usually a file or npm package.

Node.js - JavaScript runtime that lets you run JS outside browsers.

npm - Node Package Manager, for installing and managing dependencies.

package.json - File that defines your project and its dependencies.

Promise - An object representing an eventual completion or failure.

require() - CommonJS function to import modules.

V8 - Google's JavaScript engine that Node.js is built on.

================================================================================
PART 13: NEXT STEPS FOR LEARNING
================================================================================

1. EXPERIMENT WITH THE CODE
   - Add console.log() in routes to see request data
   - Modify responses and see what changes
   - Break things intentionally, then fix them

2. BUILD SOMETHING SMALL
   - A simple API that returns JSON
   - A file reader that serves file contents
   - A URL shortener

3. LEARN THESE TOPICS NEXT
   - Authentication (JWT, sessions)
   - Database queries (SQL or ORMs like Drizzle)
   - WebSockets (real-time communication)
   - Testing (Jest, Mocha)

4. RESOURCES
   - Official Node.js docs: https://nodejs.org/docs
   - Express docs: https://expressjs.com
   - Node.js tutorials: https://nodeschool.io

================================================================================
END OF NODE.JS FUNDAMENTALS GUIDE
================================================================================
